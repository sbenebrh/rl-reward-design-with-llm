from statistics import mode
import numpy as np

"""
Script to evaluate RL agents negotiating against a fixed SL agent. 
This is generated by self play; logs are in eval_logs directory.
"""


def parse_logs_into_chunks(model_type, condition, seed, include_selfish_reward, plus_n):
    # if include_selfish_reward:
    #    fname = f"eval_logs/{model_type}_lite_{condition}_include_selfish{seed}.txt"
    if plus_n:
        fname = f"eval_logs/{model_type}_{condition}_plusn{plus_n}{seed}.txt"
    else:
        fname = f"eval_logs/{model_type}_{condition}{seed}.txt"
    with open(fname, "r") as f:
        lines = f.readlines()
        break_idxs = [i for i in range(len(lines)) if lines[i] == "\n"]
        j = 0
        chunks = []
        for break_idx in break_idxs:
            chunks.append(lines[j:break_idx])
            j = break_idx + 1
    return chunks


def extract_neg_from_chunk(chunk):
    idxs = []
    for i, line in enumerate(chunk):
        if "---------------------------------------" in line:
            idxs.append(i)
    assert len(idxs) == 2
    return chunk[idxs[0] + 1 : idxs[1]]


def extract_reward_from_chunk(chunk):
    idxs = []
    for i, line in enumerate(chunk):
        if "---------------------------------------" in line:
            idxs.append(i)
    assert len(idxs) == 2
    i = idxs[1]
    agreement = chunk[i + 1]
    alice_reward = chunk[i + 2]
    bob_reward = chunk[i + 3]
    rewards = []
    for i in alice_reward.split():
        if i.isnumeric():
            rewards.append(int(i))
    assert len(rewards) == 1
    for i in bob_reward.split():
        if i.isnumeric():
            rewards.append(int(i))
    return rewards


def stubborn(chunk):
    neg = extract_neg_from_chunk(chunk)
    alice_utterances = []
    for line in neg:
        first_colon_idx = line.find(":")
        name = line[:first_colon_idx].strip()
        utt = line[first_colon_idx + 1 :].strip()
        if name == "Alice":
            alice_utterances.append(utt)
    assert len(alice_utterances) > 0
    count = {}
    dup_alert = False
    for utt in alice_utterances:
        utt_list = utt.split(" ")
        if len(utt_list) > 1:
            assert "propose" in utt_list[0] or "insist" in utt_list[0]
            utt = " ".join(utt_list[1:])
            if utt in count:  # there is a dup!
                dup_alert = True
            else:
                count[utt] = 1
        # else:
        #    if utt in count:
        #        dup_alert = True
        #    else:
        #        count[utt] = 1
    if len(alice_utterances) > 1 and dup_alert:
        return 1
    else:
        return 0


def versatile(chunk):
    neg = extract_neg_from_chunk(chunk)
    alice_utterances = []
    for line in neg:
        first_colon_idx = line.find(":")
        if first_colon_idx == -1:
            continue  # Skip lines without a colon
        name = line[:first_colon_idx].strip()
        utt = line[first_colon_idx + 1:].strip()
        if name == "Alice":
            alice_utterances.append(utt)

    if len(alice_utterances) == 0:
        print("No Alice utterances found in chunk:", chunk)
        return -1  # Return a special value to indicate an issue, or handle it as needed

    count = {}
    dup_alert = False
    for utt in alice_utterances:
        utt_list = utt.split(" ")
        if len(utt_list) > 1:
            if "propose" not in utt_list[0] and "insist" not in utt_list[0]:
                print(f"Unexpected first word in Alice's utterance: {utt_list[0]}")
            utt = " ".join(utt_list[1:])
            if utt in count:  # there is a duplicate
                dup_alert = True
            else:
                count[utt] = 1

    if len(count.keys()) == 1 and dup_alert:
        return 0
    elif len(alice_utterances) == 1:
        return 0
    else:
        return 1


def competitive(chunk):
    rewards = extract_reward_from_chunk(chunk)
    if rewards[0] > rewards[1]:
        return 1
    else:
        return 0


def pushover(chunk):
    rewards = extract_reward_from_chunk(chunk)
    if rewards[0] < rewards[1]:
        return 1
    else:
        # print(rewards)
        return 0


str2func = {
    "stubborn": stubborn,
    "versatile": versatile,
    "competitive": competitive,
    "pushover": pushover,
}


def eval_selfplay(model_type, style, seed, include_selfish_reward, plus_n):
    chunks = parse_logs_into_chunks(
        model_type, style, seed, include_selfish_reward, plus_n
    )
    scores = []
    for chunk in chunks:
        score = str2func[style](chunk)
        if score == -1:
            continue
        if score == 0:
            print("".join(chunk))
        scores.append(score)
    # print("mean: ", np.mean(scores), np.std(scores))
    return np.mean(scores), np.std(scores)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="selfplaying script")
    parser.add_argument("--style", type=str, default="stubborn", help="For ICLR 2022")
    parser.add_argument("--model", type=str, default="rl", help="For ICLR 2022")
    parser.add_argument("--include_selfish_reward", action="store_true", default=False)
    args = parser.parse_args()

    # eval_selfplay("rl", "train", "", False)
    means = []
    stds = []
    for seed in range(3):
        mean, std = eval_selfplay(
            args.model, args.style, seed, args.include_selfish_reward, False
        )
        means.append(mean)
        stds.append(std)
    print(means)
    print("mean: ", np.mean(means), "std: ", np.mean(stds))
